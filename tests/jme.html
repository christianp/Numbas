<!doctype html>
<html>
	<head>
        <title>JME unit tests</title>
		<link rel="stylesheet" href="qunit.css" type="text/css" media="screen" />
        <meta charset="utf8">
		<script src="qunit.js"></script>

		<!-- numbas stuff -->
		<script charset="UTF-8" type="text/javascript" src="jme-runtime.js" charset="utf-8"></script>
		<script charset="UTF-8" type="text/javascript" src="locales.js" charset="utf-8"></script>

		<!--JQuery scripts-->
		<script charset="UTF-8" type="text/javascript" src="../runtime/scripts/jquery/jquery.js"></script>


	</head>
	<body>
		<h1 id="qunit-header">Numbas JME unit tests</h1>
		<h2 id="qunit-banner"></h2>
		<div id="qunit-testrunner-toolbar"></div>
		<h2 id="qunit-userAgent"></h2>
		<ol id="qunit-tests"></ol>
		<div id="qunit-fixture">test markup, will be hidden</div>

		<script type="text/javascript">
			Numbas.queueScript('base',[],function() {});
			Numbas.queueScript('go',['jme','localisation'],function() {
				var jme = Numbas.jme;
				var math = Numbas.math;
				var types = jme.types;
				var tokenise = jme.tokenise;

				function raisesNumbasError(assert, fn,error,description) {
					assert.throws(fn,function(e){return e.originalMessage == error},description);
				}

				function closeEqual(assert, value,expect,message) {
					if(typeof(expect)=='number' || expect.complex)
					{
						value = Numbas.math.precround(value,10);
						expect = Numbas.math.precround(expect,10);
					}
					return assert.equal(value,expect,message);
				}

				function deepCloseEqual(assert, value,expect,message) {
					if(typeof(expect)=='number' || expect.complex)
					{
						value = Numbas.math.precround(value,10);
						expect = Numbas.math.precround(expect,10);
					}
					return assert.deepEqual(value,expect,message);
                }

                function remove_pos(tree) {
                    if(tree.tok) {
                        delete tree.tok.pos;
                    }
                    if(tree.args) {
                        tree.args.forEach(function(a) { remove_pos(a) });
                    }
                    return tree;
                }

                function treesEqual(assert, a, b, message) {
                    return deepCloseEqual(assert, remove_pos(a), remove_pos(b), message);
                }

                function tokWithPos(tok,pos) {
                    tok.pos = pos;
                    return tok;
                }

				QUnit.module('Subvars');
				QUnit.test('contentsplitbrackets',function(assert) {
					deepCloseEqual(assert, Numbas.util.contentsplitbrackets('{a}$x$'),["{a}","$","x","$"],'return the character before the maths delimiter to the plain text part');
				});
				QUnit.test('subvars',function(assert) {
					assert.equal(Numbas.jme.subvars('{1}a{',Numbas.jme.builtinScope,true),'1a{','Leave unclosed brackets alone');
				});

				QUnit.test('findvars',function(assert) {
					deepCloseEqual(assert, Numbas.jme.findvars(Numbas.jme.compile('"{a} $\\\\var{b}$ {c} \\\\[ \\\\simplify{{d}*f} \\\\]"')),['a','b','c','d'],'Findvars finds all variables used in strings');
				});

                QUnit.test('util',function(assert) {
                    deepCloseEqual(assert, Numbas.util.separateThousands(0,','),'0','0');
                    deepCloseEqual(assert, Numbas.util.separateThousands(123,','),'123','123');
                    deepCloseEqual(assert, Numbas.util.separateThousands(1234,','),'1,234','1234');
                    deepCloseEqual(assert, Numbas.util.separateThousands(12345,','),'12,345','12345');
                    deepCloseEqual(assert, Numbas.util.separateThousands(123456,','),'123,456','123456');
                    deepCloseEqual(assert, Numbas.util.separateThousands(1234567.0123,','),'1,234,567.0123','1234567.0123');
                    deepCloseEqual(assert, Numbas.util.separateThousands(-1234567.0123,','),'-1,234,567.0123','-1234567.0123');
                    deepCloseEqual(assert, Numbas.util.separateThousands(-1234567.0123,' '),'-1 234 567.0123','-1234567.0123 with space');
                });

				QUnit.module('Compiling');

                QUnit.test('Booleans', function(assert) {
                    var t_true = new types.TBool(true);
                    t_true.pos = 0
					deepCloseEqual(assert, tokenise('true'),[t_true],'true');
					deepCloseEqual(assert, tokenise('TRUE'),[t_true],'TRUE');
					deepCloseEqual(assert, tokenise('True'),[t_true],'True');
					assert.equal(tokenise('true')[0].value,true,'value is true');

                    var t_false = new types.TBool(false);
                    t_false.pos = 0
					deepCloseEqual(assert, tokenise('false'),[t_false],'false');
					deepCloseEqual(assert, tokenise('FALSE'),[t_false],'FALSE');
					deepCloseEqual(assert, tokenise('False'),[t_false],'False');
					assert.equal(tokenise('false')[0].value,false,'value is false');
				});
                QUnit.test('Numbers', function(assert) {
                    function checkNumber(str,expected) {
                        var n = tokenise(str);
                        assert.ok(n.length==1);
                        n = n[0];
                        expected = new types.TNum(expected);
                        assert.equal(n.type,expected.type);
                        deepCloseEqual(assert, n.value,expected.value);
                    }
                    checkNumber('0',0);
                    checkNumber('0.0',0);

					raisesNumbasError(assert, function(){ tokenise('.1')},'jme.tokenise.invalid near','Invalid: .1');

                    checkNumber('1',1);
                    checkNumber('1.0023',1.0023);


                    checkNumber('e',Math.E);

                    checkNumber('pi',Math.PI);
                    checkNumber('PI',Math.PI);

                    checkNumber('i',math.complex(0,1));

                    checkNumber('infinity',Infinity);
                    checkNumber('infty',Infinity);
                    checkNumber('nan',NaN);
				});

				QUnit.test('Names',function(assert) {
					deepCloseEqual(assert, tokenise('x'),[tokWithPos(new types.TName('x'),0)],'x');
					deepCloseEqual(assert, tokenise('arg123'),[tokWithPos(new types.TName('arg123'),0)],'arg123');
					deepCloseEqual(assert, tokenise('a1b2'),[tokWithPos(new types.TName('a1b2'),0)],'a1b2');
					deepCloseEqual(assert, tokenise('X'),[tokWithPos(new types.TName('X'),0)],'X');
					deepCloseEqual(assert, tokenise('xyz'),[tokWithPos(new types.TName('xyz'),0)],'xyz');
					deepCloseEqual(assert, tokenise('$x'),[tokWithPos(new types.TName('$x'),0)],'$x');
					deepCloseEqual(assert, tokenise("f'''"),[tokWithPos(new types.TName("f'''"),0)],"f'''");
					deepCloseEqual(assert, tokenise("_"),[tokWithPos(new types.TName("_"),0)],"_");
					deepCloseEqual(assert, tokenise("a_1"),[tokWithPos(new types.TName("a_1"),0)],"a_1");
					deepCloseEqual(assert, tokenise("in_code"),[tokWithPos(new types.TName("in_code"),0)],"in_code");
				});

                QUnit.test('Whitespace',function(assert) {
                    var one = new types.TNum(1);
                    one.originalValue = '1';
                    one.pos = 1;
					deepCloseEqual(assert, tokenise('\u00A01'),[one],'\\u00A01');
                    var one = new types.TNum(1);
                    one.originalValue = '1';
                    one.pos = 0;
					deepCloseEqual(assert, tokenise('1        '),[one],'1       (whitespace at end of expression)');
					deepCloseEqual(assert, tokenise('a &nbsp; + b'),[tokWithPos(new types.TName('a'),0),tokWithPos(new types.TOp('+'),9),tokWithPos(new types.TName('b'),11)],'a &nbsp; + b (html-escaped space)');
				});

				QUnit.test('Operators', function(assert) {
					deepCloseEqual(assert, tokenise('..'),[tokWithPos(new types.TOp('..'),0)],'..');
					deepCloseEqual(assert, tokenise('#'),[tokWithPos(new types.TOp('#'),0)],'#');
					deepCloseEqual(assert, tokenise('<='),[tokWithPos(new types.TOp('<='),0)],'<=');
					deepCloseEqual(assert, tokenise('>='),[tokWithPos(new types.TOp('>='),0)],'>=');
					deepCloseEqual(assert, tokenise('<>'),[tokWithPos(new types.TOp('<>'),0)],'<>');
					deepCloseEqual(assert, tokenise('&&'),[tokWithPos(new types.TOp('and'),0)],'^^');
					deepCloseEqual(assert, tokenise('||'),[tokWithPos(new types.TOp('or'),0)],'||');
					deepCloseEqual(assert, tokenise('|'),[tokWithPos(new types.TOp('|'),0)],'|');
					deepCloseEqual(assert, tokenise('*'),[tokWithPos(new types.TOp('*'),0)],'*');
					deepCloseEqual(assert, tokenise('+'),[tokWithPos(new types.TOp('+u',false,true),0)],'+');
					deepCloseEqual(assert, tokenise('-'),[tokWithPos(new types.TOp('-u',false,true),0)],'-');
					deepCloseEqual(assert, tokenise('/'),[tokWithPos(new types.TOp('/'),0)],'/');
					deepCloseEqual(assert, tokenise('^'),[tokWithPos(new types.TOp('^'),0)],'^');
					deepCloseEqual(assert, tokenise('<'),[tokWithPos(new types.TOp('<'),0)],'<');
					deepCloseEqual(assert, tokenise('>'),[tokWithPos(new types.TOp('>'),0)],'>');
					deepCloseEqual(assert, tokenise('='),[tokWithPos(new types.TOp('='),0)],'=');
					deepCloseEqual(assert, tokenise('!'),[tokWithPos(new types.TOp('not',false,true),0)],'!');
					deepCloseEqual(assert, tokenise('not'),[tokWithPos(new types.TOp('not'),0)],'not');
					deepCloseEqual(assert, tokenise('and'),[tokWithPos(new types.TOp('and'),0)],'and');
					deepCloseEqual(assert, tokenise('or'),[tokWithPos(new types.TOp('or'),0)],'or');
					deepCloseEqual(assert, tokenise('isa'),[tokWithPos(new types.TOp('isa'),0)],'isa');
					deepCloseEqual(assert, tokenise('except'),[tokWithPos(new types.TOp('except'),0)],'except');
				});

				QUnit.test('Punctuation',function(assert) {
					deepCloseEqual(assert, tokenise('('),[tokWithPos(new types.TPunc('('),0)],'(');
					deepCloseEqual(assert, tokenise(')'),[tokWithPos(new types.TPunc(')'),0)],')');
					deepCloseEqual(assert, tokenise(','),[tokWithPos(new types.TPunc(','),0)],',');
					deepCloseEqual(assert, tokenise('['),[tokWithPos(new types.TPunc('['),0)],']');
					deepCloseEqual(assert, tokenise(']'),[tokWithPos(new types.TPunc(']'),0)],']');
				});

				QUnit.test('String',function(assert) {
					deepCloseEqual(assert, tokenise('"hi"'),[tokWithPos(new types.TString('hi'),0)],'"hi"');
					deepCloseEqual(assert, tokenise("'hi'"),[tokWithPos(new types.TString('hi'),0)],"'hi'");
					deepCloseEqual(assert, tokenise('""'),[tokWithPos(new types.TString(''),0)],'"" -- empty string');
					deepCloseEqual(assert, tokenise("''"),[tokWithPos(new types.TString(''),0)],"'' -- empty string");

					deepCloseEqual(assert, tokenise('"hi \\"Bob\\""'),[tokWithPos(new types.TString('hi "Bob"'),0)],'"hi \\"Bob\\"" -- escape quotes');
					deepCloseEqual(assert, tokenise("'hi \\'Bob\\''"),[tokWithPos(new types.TString("hi 'Bob'"),0)],"'hi \\'Bob\\'' -- escape quotes");
                    deepCloseEqual(assert, tokenise("'hi \\{Bob\\}'"),[tokWithPos(new types.TString("hi \\{Bob\\}"),0)],"'hi \\{Bob\\}' -- keep slashes before braces");

					raisesNumbasError(assert, function() {tokenise('"hi')},'jme.tokenise.invalid near','Invalid: "hi');
					raisesNumbasError(assert, function() {tokenise('hi"')},'jme.tokenise.invalid near','Invalid: hi"');

					deepCloseEqual(assert, tokenise('"hi \\n there"'),[tokWithPos(new types.TString('hi \n there'),0)],'"hi \\n there"');
					deepCloseEqual(assert, tokenise('"hi \\\\n there"'),[tokWithPos(new types.TString('hi \\n there'),0)],'"hi \\\\n there"');
					deepCloseEqual(assert, tokenise('"hi \\\\\\n there"'),[tokWithPos(new types.TString('hi \\\n there'),0)],'"hi \\\\\\n there"');
				});

				QUnit.test('Implicit multiplication',function(assert) {
					treesEqual(assert, compile('x 5'),compile('x*5'),'x 5');
					treesEqual(assert, compile('5x'),compile('5*x'),'5x');
					treesEqual(assert, compile('x x'),compile('x*x'),'x x');
					treesEqual(assert, compile('5(x+1)'),compile('5*(x+1)'),'5(x+1)');
					treesEqual(assert, compile('(x+1)(x+2)'),compile('(x+1)*(x+2)'),'(x+1)(x+2)');
				});

				QUnit.test('Invalid expressions',function(assert) {
					raisesNumbasError(assert, function(){tokenise('x.1')},'jme.tokenise.invalid near','Invalid: x.1');
				});

				var compile = function(s){ return jme.compile(s,jme.builtinScope) };

				QUnit.test('jme.shunt',function(assert) {
					raisesNumbasError(assert, function(){ compile('x+') },'jme.shunt.not enough arguments','not enough arguments: x+')
					raisesNumbasError(assert, function(){ compile('!') },'jme.shunt.not enough arguments','not enough arguments: !')
					raisesNumbasError(assert, function(){ compile('f x,y')},'jme.shunt.no left bracket in function','no left bracket in function: f x,y');
					raisesNumbasError(assert, function(){ compile('x]') },'jme.shunt.no left square bracket','no left square bracket: x]');
					raisesNumbasError(assert, function(){ compile('x)') },'jme.shunt.no left bracket','no left bracket: x)');
					raisesNumbasError(assert, function(){ compile('(x') },'jme.shunt.no right bracket','no right bracket: (x');
					raisesNumbasError(assert, function(){ compile('[x,y') },'jme.shunt.no right square bracket','no right square bracket: [x,y');
					raisesNumbasError(assert, function(){ compile('1 2 3') },'jme.shunt.missing operator','missing operator: 1 2 3');
                    raisesNumbasError(assert, function(){ compile('["a":1,2]') },'jme.shunt.list mixed argument types','mixed list/dict arguments: ["a":1,2]');
                    raisesNumbasError(assert, function(){ compile('[2,"a":1]') },'jme.shunt.list mixed argument types','mixed list/dict arguments: [2,"a":1]');
				})
			
				
				QUnit.module('Evaluating');

				QUnit.test('Numbas.math',function(assert) {
					assert.equal(Numbas.math.countSigFigs('1.10'),3,"math.countSigFigs('1.10')==3");
					assert.equal(Numbas.math.countSigFigs('-1.10'),3,"math.countSigFigs('-1.10')==3");
					assert.equal(Numbas.math.countSigFigs('1.23e6'),3,"math.countSigFigs('1.23e6')==3");
					assert.equal(Numbas.math.countSigFigs('1.23e-6'),3,"math.countSigFigs('1.23e-6')==3");
					assert.equal(Numbas.math.countSigFigs('1.23E6'),3,"math.countSigFigs('1.23e6')==3");
					assert.equal(Numbas.math.countSigFigs('1.23E-6'),3,"math.countSigFigs('1.23e-6')==3");
                    assert.equal(Numbas.math.countSigFigs('1.20e6',5),3,"math.countSigFigs('1.20e6',5)==3 (the max setting doesn't have any meaning for E notation)");
                    assert.ok(Numbas.math.eq(NaN,NaN),'NaN = NaN');
				});

                var evaluate = function(t,scope) { 
                    scope = scope || Numbas.jme.builtinScope;
                    if(scope.__proto__!=Numbas.jme.Scope.prototype) {
                        scope = new Numbas.jme.Scope([Numbas.jme.builtinScope,scope]);
                    }
                    return jme.evaluate(t,scope)
                };

				QUnit.test('jme.typecheck',function(assert) {
					raisesNumbasError(assert, function(){ evaluate('x()') },'jme.typecheck.function not defined','function not defined: x()');
					raisesNumbasError(assert, function(){ evaluate('x+y',new jme.Scope()) },'jme.typecheck.op not defined','op not defined with empty scope: x+y');
					raisesNumbasError(assert, function(){ evaluate('gcd(2)') },'jme.typecheck.no right type definition','no right type definition: gcd(2)');
				});

				function getValue(e){ return e.value; }	//mapped on lists to just get the javascript primitives of their elements

				QUnit.test('Variables',function(assert) {
					var scope = {variables: {
						x: new types.TNum(1),
						name: new types.TString('Bob')
					}};
					closeEqual(assert, evaluate('y',scope).type,'name','undefined variable remains a TName')
					closeEqual(assert, evaluate('x',scope).value,1,'substitute variable x=1')
					closeEqual(assert, evaluate('"hi {name}"',scope).value,'hi Bob','substitute into string');

                    /*
                    // Removed while I think about how I want this to work

					var expr = new Numbas.jme.types.TExpression(Numbas.jme.compile('x+1'));
					var expr_scope = new Numbas.jme.Scope([Numbas.jme.builtinScope,{variables:{expr:expr, n: Numbas.jme.builtinScope.evaluate('2')}}]);
					var tree = Numbas.jme.substituteTree(Numbas.jme.compile('expr/n'),expr_scope,true);
					var s = Numbas.jme.display.treeToJME(tree);
					closeEqual(assert, s,'(x + 1)/2','Substitute TExpression')

					var expr = new Numbas.jme.types.TExpression(Numbas.jme.compile('x+n'));
					var expr_scope = new Numbas.jme.Scope([Numbas.jme.builtinScope,{variables:{expr:expr, n: Numbas.jme.builtinScope.evaluate('2')}}]);
					var tree = Numbas.jme.substituteTree(Numbas.jme.compile('expr/n'),expr_scope,true);
					var s = Numbas.jme.display.treeToJME(tree);
                    closeEqual(assert, s,'(x + 2)/2','Substitute TExpression - substitution into sub-expression')

                    */
				});

				QUnit.test('Literals',function(assert) {
					closeEqual(assert, evaluate('1').value,1,'1');
					closeEqual(assert, evaluate('true').value,true,'true');
					deepCloseEqual(assert, evaluate('1..3').value,[1,3,1],'1..3');
					deepCloseEqual(assert, evaluate('[1,2]').value.map(getValue),[1,2],'[1,2]');
					deepCloseEqual(assert, evaluate('[1,"hi",true]').value.map(getValue),[1,"hi",true],'[1,"hi",true]');
					closeEqual(assert, evaluate('"hi"').value,'hi','"hi"');
					closeEqual(assert, evaluate("'hi'").value,'hi',"'hi'");
					closeEqual(assert, evaluate('x').type,'name','x');
				});

				QUnit.test('Operator precedence',function(assert) {
					closeEqual(assert, evaluate('2*3!').value,12,'factorial highest: 2*3! = 2*(3!)');
					closeEqual(assert, evaluate('(2*3)!').value,6*5*4*3*2,'brackets work: (2*3)! = 6!');
					closeEqual(assert, evaluate('2^1^2').value,2,'exponentiation is right-associative: 2^1^2 = 2^(1^2)');
					closeEqual(assert, evaluate('2*3^2').value,18,'exponentation before multiplication: 2*3^2 = 2*(3^2)');
					closeEqual(assert, evaluate('5*4+3*2').value,26,'multiplication before addition: 5*4+3*2 = (5*4)+(3*2)');
					closeEqual(assert, evaluate('5/4+3/2').value,2.75,'division before addition: 5/4+3/2 = (5/4)+(3/2)');
					closeEqual(assert, evaluate('5*4/3-5/3*4').value,0,'multiplication and division equal precedence: 5*4/3 = 5/3*4');
					closeEqual(assert, evaluate('1/2/3').value,1/6,'division is left-associative: 1/2/3 = (1/2)/3');
					closeEqual(assert, evaluate('5-+2').value,3,'unary addition: 5-+2 = 5-2');
					closeEqual(assert, evaluate('5--2').value,7,'unary minus: 5--2 = 5+2');
					closeEqual(assert, evaluate('3*2^-1').value,1.5,'unary minus with power');
					closeEqual(assert, evaluate('3+--2').value,5,'lots of unary minus in a chain');
					closeEqual(assert, evaluate('-2^2').value,-4,'unary minus before a power');
					closeEqual(assert, evaluate('-2+3').value,1,'unary minus before addition');
					deepCloseEqual(assert, evaluate('-vector(1,2,-3.3)').value,[-1,-2,3.3],'unary minus: -vector(1,2,-3.3)==vector(-1,-2,3.3)');
					deepCloseEqual(assert, evaluate('-matrix([1,0],[2,3])').value,[[-1,0],[-2,-3]],'unary minus: -matrix([1,0],[2,3])==matrix([-1,0],[-2,-3]))');
					assert.ok(evaluate('1+2*3|7^2'),'"divides" after arithmetic');
					closeEqual(assert, evaluate('1+2..5').value[0],3,'arithmetic before range .. operator: 1+2..5 = (1+2)..5');
					closeEqual(assert, evaluate('1..5#2').value[2],2,'range step operator');
					assert.ok(evaluate('1..2 except 3'),'except operator');
					assert.ok(evaluate('1+2<2+3'),'comparison operator lower than arithmetic: 1+2<2+3 = (1+2)<(2+3)');
					assert.ok(evaluate('1<2=2<3'),'equality after inequality');
					assert.ok(evaluate('1<2 && 3<4'),'AND after comparisons');
					closeEqual(assert, evaluate('true or false and false').value,true,'OR after AND');
					closeEqual(assert, evaluate('true xor true or true').value,false,'XOR after OR');
					assert.ok(evaluate('1/-7'),'unary operation straight after a binary operation');
					closeEqual(assert, evaluate('3!+4!').value,30,'3!+4!=30; postfix operators interact with binary operators properly');
				});

				QUnit.test('Synonyms',function(assert) {
					closeEqual(assert, evaluate('5!=fact(5)').value,true,'x! == fact(x)');
					closeEqual(assert, evaluate('true and true = true & true = true && true').value,true,'true == & == &&');
					closeEqual(assert, evaluate('1|5 = 1 divides 5').value,true,'x|y == x divides y');
					closeEqual(assert, evaluate('true||false = true or false').value,true,'x||y == x or y');
					closeEqual(assert, evaluate('sqr(2) = sqrt(2)').value,true,'sqr == sqrt');
					closeEqual(assert, evaluate('gcf(2,3) = gcd(2,3)').value,true,'gcf == gcd');
					closeEqual(assert, evaluate('sgn(4) = sign(4)').value,true,'sgn == sign');
					closeEqual(assert, evaluate('len(32) = abs(32) and length(32) = abs(32)').value,true,'len == length == abs');
                    closeEqual(assert, jme.compile('verb(2)',jme.builtinScope,{notypecheck:true}).tok.name,'verbatim','verb == verbatim');
                    assert.ok(jme.compile('length+1'),'length as a variable name')
				});

				QUnit.test('Types (isa)',function(assert) {
					closeEqual(assert, evaluate('1 isa "number"').value,true,'1 isa "number"');
					closeEqual(assert, evaluate('1 isa "complex"').value,false,'1 isa "complex"');
					closeEqual(assert, evaluate('i isa "complex"').value,true,'i isa "complex"');
					closeEqual(assert, evaluate('1+i isa "complex"').value,false,'1+i isa "complex"');
					closeEqual(assert, evaluate('"1" isa "number"').value,false,'"1" isa "number"');
					closeEqual(assert, evaluate('"1" isa "string"').value,true,'"1" isa "string"');
					closeEqual(assert, evaluate('[] isa "list"').value,true,'[] isa "list"');
					closeEqual(assert, evaluate('xy isa "name"').value,true,'xy isa "name"');
				});

				QUnit.test('Arithmetic',function(assert) {
					closeEqual(assert, evaluate('+2').value,2,'+2');
					closeEqual(assert, evaluate('-2').value,-2,'-2');
					closeEqual(assert, evaluate('1+2').value,3,'1+2');
					deepCloseEqual(assert, evaluate('i+1').value,math.complex(1,1),'i+1');
					deepCloseEqual(assert, evaluate('[1,2]+[3,4]').value.map(getValue),[1,2,3,4],'[1,2]+[3,4]');
					deepCloseEqual(assert, evaluate('[1,2]+3').value.map(getValue),[1,2,3],'[1,2]+3');
					deepCloseEqual(assert, evaluate('["x","y"]+"z"').value.map(getValue),['x','y','z'],'["x","y"]+"z"');
					closeEqual(assert, evaluate('"hi "+"there"').value,'hi there','"hi"+" there"');
					closeEqual(assert, evaluate('"n: "+1').value,'n: 1','"n: "+1');
					closeEqual(assert, evaluate('2+" things"').value,'2 things','2+" things"');
					deepCloseEqual(assert, evaluate('vector(1,2)+vector(2,3)').value,[3,5],'vector(1,2)+vector(2,3)');
					deepCloseEqual(assert, evaluate('matrix([1,0],[0,1])+matrix([0,1],[1,0])').value,[[1,1],[1,1]],'matrix([1,0],[0,1])+matrix([0,1],[1,0])');
					closeEqual(assert, evaluate('3-13').value,-10,'3-13');
					deepCloseEqual(assert, evaluate('vector(1,2)-vector(5,5)').value,[-4,-3],'vector(1,2)-vector(5,5)');
					deepCloseEqual(assert, evaluate('matrix([1,0],[0,1])-matrix([2,1],[2,1])').value,[[-1,-1],[-2,0]],'matrix([1,0],[0,1])-matrix([2,1],[2,1])');
					closeEqual(assert, evaluate('5*4').value,20,'5*4');
					closeEqual(assert, evaluate('i*i').value,-1,'i*i');
					deepCloseEqual(assert, evaluate('5*vector(1,2)').value,[5,10],'5*vector(1,2)');
					deepCloseEqual(assert, evaluate('vector(1,2)*5').value,[5,10],'vector(1,2)*5');
					deepCloseEqual(assert, evaluate('matrix([1,1],[3,2])*vector(1,2)').value,[3,7],'matrix([1,1],[3,2])*vector(1,2)');
					deepCloseEqual(assert, evaluate('5*matrix([1,0],[0,1])').value,[[5,0],[0,5]],'5*matrix([1,0],[0,1])');
					deepCloseEqual(assert, evaluate('matrix([1,0],[0,1])*5').value,[[5,0],[0,5]],'matrix([1,0],[0,1])*5');
					deepCloseEqual(assert, evaluate('matrix([1,2],[1,1])*matrix([2,3],[4,5])').value,[[10,13],[6,8]],'matrix([1,2],[1,1])*matrix([2,3],[4,5])');
					closeEqual(assert, evaluate('5/2').value,2.5,'5/2');
					deepCloseEqual(assert, evaluate('5/(1+i)').value,math.complex(2.5,-2.5),'5/(1+i)');
					deepCloseEqual(assert, evaluate('(1+i)/5').value,math.complex(0.2,0.2),'(1+i)/5');
					deepCloseEqual(assert, evaluate('(1+i)/(2-i)').value,math.complex(0.2,0.6),'(1+i)/(2+i)');
					closeEqual(assert, evaluate('2^4').value,16,'2^4');
					closeEqual(assert, evaluate('(-6)^2').value,36,'(-6)^2 - see https://github.com/numbas/examples/issues/4');
					deepCloseEqual(assert, evaluate('(1+i)^0').value,1,'(1+i)^0');
					deepCloseEqual(assert, evaluate('(1+i)^5').value,math.complex(-4,-4),'(1+i)^5');
					deepCloseEqual(assert, evaluate('(1+i)^6').value,math.complex(0,-8),'(1+i)^6');
					deepCloseEqual(assert, evaluate('(1+i)^(-2)').value,math.complex(0,-0.5),'(1+i)^(-2)');
					deepCloseEqual(assert, evaluate('(1+i)^(-3)').value,math.complex(-0.25,-0.25),'(1+i)^(-3)');
					deepCloseEqual(assert, evaluate('2^i').value,math.complex(0.7692389013639721,0.6389612763136348),'2^i');
				});

				QUnit.test('Logic',function(assert) {
					closeEqual(assert, evaluate('0<2').value,true,'0<2');
					closeEqual(assert, evaluate('2<0').value,false,'2<0');
					closeEqual(assert, evaluate('0<-0').value,false,'0<0');
					closeEqual(assert, evaluate('0>2').value,false,'0>2');
					closeEqual(assert, evaluate('2>0').value,true,'2>0');
					closeEqual(assert, evaluate('0>-0').value,false,'0>0');

					raisesNumbasError(assert, function(){ evaluate('1<i') },'math.order complex numbers',"can't order complex numbers");
					raisesNumbasError(assert, function(){ evaluate('i>1') },'math.order complex numbers',"can't order complex numbers");
					raisesNumbasError(assert, function(){ evaluate('i<=1') },'math.order complex numbers',"can't order complex numbers");
					raisesNumbasError(assert, function(){ evaluate('1>=i') },'math.order complex numbers',"can't order complex numbers");

					closeEqual(assert, evaluate('1=1').value,true,'1=1');
					closeEqual(assert, evaluate('1/5=0.2').value,true,'1/5=0.2');
					closeEqual(assert, evaluate('"abcdef"=\'abcdef\'').value,true,'"abcdef"=\'abcdef\'');
					closeEqual(assert, evaluate('"abcdef"=" abcdef "').value,false,'"abcdef"=" abcdef "');
					closeEqual(assert, evaluate('"abcdef"="ABCDEF"').value,false,'"abcdef"="ABCDEF"');
					closeEqual(assert, evaluate('"<b>abcdef</b>"="*abcdef*"').value,false,'"<b>abcdef</b>="*abcdef*"');
					closeEqual(assert, evaluate('true=true').value,true,'true=true');
					closeEqual(assert, evaluate('false=false').value,true,'false=false');
					closeEqual(assert, evaluate('true=false').value,false,'true=false');
					closeEqual(assert, evaluate('[0,1,2]=[0,1,2]').value,true,'[0,1,2]=[0,1,2]');
					closeEqual(assert, evaluate('[0,4,2]=[0,1,2]').value,false,'[0,4,2]=[0,1,2]');
					closeEqual(assert, evaluate('[0,1,2]=[0,1,2,3]').value,false,'[0,1,2]=[0,1,2,3]');
					closeEqual(assert, evaluate('0..4=0..4#1').value,true,'0..4=0..4#1');
					closeEqual(assert, evaluate('0..4=0..4#2').value,false,'0..4=0..4#2');
					closeEqual(assert, evaluate('0="0"').value,false,'0="0"');
					closeEqual(assert, evaluate('a=a').value,true,'a=a');
					closeEqual(assert, evaluate('0<>1').value,true,'0<>1');
					closeEqual(assert, evaluate('1<>1').value,false,'0<>1');

					closeEqual(assert, evaluate('not true').value,false,'not true');
					closeEqual(assert, evaluate('not false').value,true,'not false');

					closeEqual(assert, evaluate('true and false').value,false,'true and false');
					closeEqual(assert, evaluate('false and true').value,false,'false and true');
					closeEqual(assert, evaluate('true and true').value,true,'true and true');
					closeEqual(assert, evaluate('false and false').value,false,'false and false');

					closeEqual(assert, evaluate('true or false').value,true,'true or false');
					closeEqual(assert, evaluate('false or true').value,true,'false or true');
					closeEqual(assert, evaluate('true or true').value,true,'true or true');
					closeEqual(assert, evaluate('false or false').value,false,'false or false');

					closeEqual(assert, evaluate('true xor false').value,true,'true xor false');
					closeEqual(assert, evaluate('false xor true').value,true,'false xor true');
					closeEqual(assert, evaluate('true xor true').value,false,'true xor true');
					closeEqual(assert, evaluate('false xor false').value,false,'false xor false');

					closeEqual(assert, evaluate('NaN=NaN').value,true,'nan=NaN');
				});

				QUnit.test('Number functions',function(assert) {
					closeEqual(assert, evaluate('abs(-5.4)').value,5.4,'abs(-5.4)');
					closeEqual(assert, evaluate('abs(1+i)').value,Math.sqrt(2),'abs(1+i)');
					closeEqual(assert, evaluate('abs([1,2,3,4])').value,4,'abs([1,2,3,4])');
					closeEqual(assert, evaluate('abs(1..5)').value,5,'abs(1..5)');
					closeEqual(assert, evaluate('abs(1..5#1.2)').value,4,'abs(1..5#1.2)');
					closeEqual(assert, evaluate('abs(1..4#0)').value,3,'abs(1..4#0)');
					closeEqual(assert, evaluate('abs(vector(3,4))').value,5,'abs(vector(3,4))');
					closeEqual(assert, evaluate('abs(vector(3,4,5,5,5))').value,10,'abs(vector(3,4,5,5,5))');
					closeEqual(assert, evaluate('arg(1+i)').value,Math.PI/4,'arg(1+i)');
					closeEqual(assert, evaluate('arg(-1-i)').value,-3*Math.PI/4,'arg(1+i)');
					closeEqual(assert, evaluate('arg(0)').value,0,'arg(0)');
					closeEqual(assert, evaluate('arg(1)').value,0,'arg(1)');

					closeEqual(assert, evaluate('re(1)').value,1,'re(1)');
					closeEqual(assert, evaluate('re(i)').value,0,'re(i)');
					closeEqual(assert, evaluate('re(5+6i)').value,5,'re(5+6i)');
					closeEqual(assert, evaluate('im(1)').value,0,'im(1)');
					closeEqual(assert, evaluate('im(i)').value,1,'im(i)');
					closeEqual(assert, evaluate('im(5+6i)').value,6,'im(5+6i)');
					closeEqual(assert, evaluate('conj(1)').value,1,'conj(1)');
					deepCloseEqual(assert, evaluate('conj(i)').value,math.complex(0,-1),'conj(i)');
					deepCloseEqual(assert, evaluate('conj(5+6i)').value,math.complex(5,-6),'conj(5+6i)');

					closeEqual(assert, evaluate('isint(0)').value,true,'isint(0)');
					closeEqual(assert, evaluate('isint(542)').value,true,'isint(542)');
					closeEqual(assert, evaluate('isint(-431)').value,true,'isint(-431)');
					closeEqual(assert, evaluate('isint(4/3)').value,false,'isint(4/3)');
					closeEqual(assert, evaluate('isint(-43.1)').value,false,'isint(-43.1)');
					closeEqual(assert, evaluate('isint(5i)').value,false,'isint(5i)');

					closeEqual(assert, evaluate('degrees(0)').value,0,'degrees(0)');
					closeEqual(assert, evaluate('degrees(pi)').value,180,'degrees(pi)');
					closeEqual(assert, evaluate('degrees(1)').value,57.29577951308232,'degrees(1)');
					closeEqual(assert, evaluate('degrees(5.5*pi)').value,990,'degrees(5.5*pi)');
					deepCloseEqual(assert, evaluate('degrees(pi*i)').value,math.complex(0,180),'degrees(pi*i)');

					closeEqual(assert, evaluate('sign(54)').value,1,'sign(54)');
					closeEqual(assert, evaluate('sign(0.5)').value,1,'sign(0.5)');
					closeEqual(assert, evaluate('sign(0)').value,0,'sign(0)');
					closeEqual(assert, evaluate('sign(-43)').value,-1,'sign(-43)');
					deepCloseEqual(assert, evaluate('sign(4-i)').value,math.complex(1,-1),'sign(4-i)');

					closeEqual(assert, evaluate('award(5,true)').value,5,'award(5,true)');
					closeEqual(assert, evaluate('award(5,false)').value,0,'award(5,true)');
				});

				QUnit.test('Number theory/combinatorics',function(assert) {
					deepCloseEqual(assert, evaluate('mod(0,0)').value,NaN,'mod(0,0)');
					deepCloseEqual(assert, evaluate('mod(5,0)').value,NaN,'mod(5,0)');
					closeEqual(assert, evaluate('mod(13,2)').value,1,'mod(13,2)');
					closeEqual(assert, evaluate('mod(4.765,3)').value,1.765,'mod(4.765,3)');
					closeEqual(assert, evaluate('mod(-13,6)').value,5,'mod(-13,6)');
					closeEqual(assert, evaluate('mod(2.4,1.1)').value,0.2,'mod(2.4,1.1)');

					closeEqual(assert, evaluate('max(3,5)').value,5,'max(3,5)');
					closeEqual(assert, evaluate('max(54,1.5654)').value,54,'max(54,1.5654)');
					closeEqual(assert, evaluate('max(-32,4)').value,4,'max(-32,4)');
					raisesNumbasError(assert, function(){ evaluate('max(i,1+i)') },'math.order complex numbers',"can't order complex numbers: max(i,1+i)");

					closeEqual(assert, evaluate('min(3,5)').value,3,'min(3,5)');
					closeEqual(assert, evaluate('min(54,1.5654)').value,1.5654,'min(54,1.5654)');
					closeEqual(assert, evaluate('min(-32,4)').value,-32,'min(-32,4)');
					raisesNumbasError(assert, function(){ evaluate('min(i,1+i)') },'math.order complex numbers',"can't order complex numbers: min(i,1+i)");

					closeEqual(assert, evaluate('perm(5,4)').value,120,'perm(5,4)');
					closeEqual(assert, evaluate('perm(6,1)').value,6,'perm(6,1)');
                    raisesNumbasError(assert, function() {evaluate('perm(2,3)')},'math.permutations.n less than k','n less than k: perm(2,3)');
                    raisesNumbasError(assert, function() {evaluate('perm(-2,3)')},'math.permutations.n less than zero','n less than zero: perm(-2,3)');
                    raisesNumbasError(assert, function() {evaluate('perm(2,-3)')},'math.permutations.k less than zero','k less than zero: perm(2,-3)');
					raisesNumbasError(assert, function() {evaluate('perm(i,1)')},'math.permutations.complex',"error: can't compute permutations of complex numbers: perm(i,1)");
					raisesNumbasError(assert, function() {evaluate('perm(1,i)')},'math.permutations.complex',"error: can't compute permutations of complex numbers: perm(1,i)");

					closeEqual(assert, evaluate('comb(5,4)').value,5,'comb(5,4)');
					closeEqual(assert, evaluate('comb(6,1)').value,6,'comb(6,1)');
					closeEqual(assert, evaluate('comb(7,3)').value,35,'comb(6,1)');
                    raisesNumbasError(assert, function() {evaluate('comb(2,3)')},'math.combinations.n less than k','n less than k: comb(2,3)');
                    raisesNumbasError(assert, function() {evaluate('comb(-2,3)')},'math.combinations.n less than zero','n less than zero: comb(-2,3)');
                    raisesNumbasError(assert, function() {evaluate('comb(2,-3)')},'math.combinations.k less than zero','k less than zero: comb(2,-3)');
					raisesNumbasError(assert, function() {evaluate('comb(i,1)')},'math.combinations.complex',"error: can't compute combinations of complex numbers: comb(i,1)");
					raisesNumbasError(assert, function() {evaluate('comb(1,i)')},'math.combinations.complex',"error: can't compute combinations of complex numbers: comb(1,i)");

					closeEqual(assert, evaluate('gcd(36,15)').value,3,'gcd(36,15)');
					closeEqual(assert, evaluate('gcd(1.1,15)').value,1,'gcd(1.1,15)');
					closeEqual(assert, evaluate('gcd(-60,18)').value,6,'gcd(-60,18)');
					closeEqual(assert, evaluate('gcd(60,-18)').value,6,'gcd(60,-18)');
					raisesNumbasError(assert, function(){ evaluate('gcd(2i,4)') },'math.gcf.complex',"can't take gcf of complex numbers: gcf(2i,4)");

					closeEqual(assert, evaluate('lcm(3,7)').value,21,'lcm(3,7)');
					closeEqual(assert, evaluate('lcm(4,6)').value,12,'lcm(4,12)');
					closeEqual(assert, evaluate('lcm(-10,35)').value,70,'lcm(-10,35)');
					raisesNumbasError(assert, function(){ evaluate('lcm(2,i)') },'math.lcm.complex',"can't find lcm of complex numbers: lcm(2,i)");

					closeEqual(assert, evaluate('5|25').value,true,'5|25');
					closeEqual(assert, evaluate('6|42').value,true,'6|42');
					closeEqual(assert, evaluate('4|42').value,false,'4|42');
					closeEqual(assert, evaluate('-4|40').value,true,'-4|40');
					closeEqual(assert, evaluate('4|-40').value,true,'4|-40');
					closeEqual(assert, evaluate('i|2i').value,false,'i|2i');
				});

				QUnit.test('Rounding',function(assert) {
					closeEqual(assert, evaluate('radians(0)').value,0,'radians(0)');
					closeEqual(assert, evaluate('radians(180)').value,Math.PI,'radians(180)');
					closeEqual(assert, evaluate('radians(1080)').value,6*Math.PI,'radians(1080)');
					deepCloseEqual(assert, evaluate('radians(90+360i)').value,math.complex(Math.PI/2,2*Math.PI),'radians(90+360i)');

					closeEqual(assert, evaluate('ceil(0.1)').value,1,'ceil(0.1)');
					closeEqual(assert, evaluate('ceil(532.9)').value,533,'cei(532.9)');
					closeEqual(assert, evaluate('ceil(0)').value,0,'ceil(0)');
					closeEqual(assert, evaluate('ceil(-14.6)').value,-14,'ceil(-14.6)');
					deepCloseEqual(assert, evaluate('ceil(1.7-2.3i)').value,math.complex(2,-2),'ceil(1.7-2.3i)');

					closeEqual(assert, evaluate('floor(0.1)').value,0,'floor(0.1)');
					closeEqual(assert, evaluate('floor(532.9)').value,532,'cei(532.9)');
					closeEqual(assert, evaluate('floor(0)').value,0,'floor(0)');
					closeEqual(assert, evaluate('floor(-14.6)').value,-15,'floor(-14.6)');
					deepCloseEqual(assert, evaluate('floor(1.2i)').value,math.complex(0,1),'floor(1.2i)');

					closeEqual(assert, evaluate('trunc(0)').value,0,'trunc(0)');
					closeEqual(assert, evaluate('trunc(5)').value,5,'trunc(5)');
					closeEqual(assert, evaluate('trunc(14.3)').value,14,'trunc(14.3)');
					closeEqual(assert, evaluate('trunc(-4.76)').value,-4,'trunc(-4.76)');
					deepCloseEqual(assert, evaluate('trunc(0.5+4.75i)').value,math.complex(0,4),'trunc(0.5+4.75i)');

					closeEqual(assert, evaluate('fract(0)').value,0,'fract(0)');
					closeEqual(assert, evaluate('fract(5)').value,0,'fract(5)');
					closeEqual(assert, evaluate('fract(14.3)').value,0.3,'fract(14.3)');
					closeEqual(assert, evaluate('fract(-4.76)').value,-0.76,'fract(-4.76)');
					deepCloseEqual(assert, evaluate('fract(0.5+4.75i)').value,math.complex(0.5,0.75),'fract(0.5+4.75i)');

					closeEqual(assert, evaluate('round(0)').value,0,'round(0)');
					closeEqual(assert, evaluate('round(12321)').value,12321,'round(12321)');
					closeEqual(assert, evaluate('round(1.4)').value,1,'round(1.4)');
					closeEqual(assert, evaluate('round(4.9)').value,5,'round(4.5)');
					closeEqual(assert, evaluate('round(11.5)').value,12,'round(11.5)');
					closeEqual(assert, evaluate('round(-3.2)').value,-3,'round(-3.2)');
					closeEqual(assert, evaluate('round(-3.5)').value,-3,'round(-3.5)');
					closeEqual(assert, evaluate('round(-50)').value,-50,'round(-50)');
					deepCloseEqual(assert, evaluate('round(1.4-6.7i)').value,math.complex(1,-7),'round(1.4-6.7i)');

					assert.equal(evaluate('precround(1.1234567891011121314151617181920,0)').value,1,'precround(1.1234567891011121314151617181920,0) - round to integer');
					assert.equal(evaluate('precround(1.1234567891011121314151617181920,1)').value,1.1,'precround(1.1234567891011121314151617181920,1) - round to 1 d.p.');
					assert.equal(evaluate('precround(1.1234567891011121314151617181920,5)').value,1.12346,'precround(1.1234567891011121314151617181920,5) - round to 5 d.p. - should round up');
					assert.equal(evaluate('precround(1.1234567891011121314151617181920,20)').value,1.12345678910111213142,'precround(1.1234567891011121314151617181920,20)');
					assert.equal(evaluate('precround(1.9999,3)').value,2,'precround(1.9999,3) - round to 3 dp results in integer');
					assert.equal(evaluate('precround(-132.6545,3)').value,-132.654,'precround(-132.6545,3) - round on 5 in negative number rounds up');
					assert.equal(evaluate('precround(123456789012,8)').value,123456789012,'precround(123456789012,8) - only multiply fractional part, to get better precision');
					assert.equal(evaluate('precround(4+488/1000,3)').value,4.488,'precround(4+488/1000,3) - try not to add floating point error in the middle of precround');
					assert.equal(evaluate('precround(0.05,2)').value,0.05,'precround(0.05,2)');
					assert.equal(evaluate('precround(-0.05,2)').value,-0.05,'precround(-0.05,2)');
					assert.equal(evaluate('precround(-2.51,0)').value,-3,'precround(-2.51,0)');

					assert.equal(evaluate('precround(237.55749999999998,3)').value,237.558,'precround(237.55749999999998,3)==237.558');
					assert.equal(evaluate('precround(237.55748999999998,3)').value,237.557,'precround(237.55748999999998,3)==237.557');
					assert.equal(evaluate('precround(-237.55750000000001,3)').value,-237.557,'precround(-237.55750000000001,3)==-237.557');
					assert.equal(evaluate('precround(-237.55751000000001,3)').value,-237.558,'precround(-237.55751000000001,3)==-237.558');

					assert.equal(evaluate('siground(0.123,2)').value,0.12,'siground(0.123,2)');
					assert.equal(evaluate('siground(123456.123456,3)').value,123000,'siground(123456.123456,3)');
					assert.equal(evaluate('siground(-32.45,3)').value,-32.4,'siground(-32.45,3)');
					assert.equal(evaluate('siground(-32452,2)').value,-32000,'siground(-32452,2)');
					assert.equal(evaluate('siground(-2.51,1)').value,-3,'siground(-2.51,1)');
				});

                QUnit.test('Currency',function(assert) {
                    assert.equal(evaluate('currency(2.01,"£","p")').value,'£2.01','currency(2.01,"£","p")');
                    assert.equal(evaluate('currency(2.00001,"£","p")').value,'£2','currency(2.00001,"£","p")');
                    assert.equal(evaluate('currency(2.999,"£","p")').value,'£3','currency(2.999,"£","p")');
                    assert.equal(evaluate('currency(0.999,"£","p")').value,'£1','currency(0.999,"£","p")');
                    assert.equal(evaluate('currency(0.99,"£","p")').value,'99p','currency(0.99,"£","p")');
                });

				QUnit.test('Random numbers',function(assert) {
					var acc = true;
					for(var i=0;i<10;i++) {
						acc &= [1,2,3,4,5].contains(evaluate('random(1..5)').value);
					}
					assert.equal(acc,true,'random(1..5) in [1,2,3,4,5]');
					assert.equal(evaluate('random(1..1)').value,1,'random(1..1) = 1');
					raisesNumbasError(assert, function(){ evaluate('random([])') },'math.choose.empty selection','empty selection: random([])');
					acc = true;
					for(i=0;i<10;i++) {
						acc &= ['a','b','c'].contains(evaluate('random(["a","b","c"])').value);
					}
					assert.equal(acc,true,'random(["a","b","c"]) in ["a","b","c"]');

					acc = true;
					for(var i=0;i<10;i++) {
						acc &= [1,2,'a'].contains(evaluate('random(1,2,"a")').value);
					}
					assert.equal(acc,true,'random(1,2,"a") in [1,2,"a"]');

					raisesNumbasError(assert, function(){ evaluate('random()') },'math.choose.empty selection','empty selection: random()');

					deepCloseEqual(assert, evaluate('deal(4)').value.map(getValue).sort(),[0,1,2,3],'deal(4)');
				});

				QUnit.test('Exponentials',function(assert) {
					closeEqual(assert, evaluate('sqrt(2)').value,Math.sqrt(2),'sqrt(2)');
					deepCloseEqual(assert, evaluate('sqrt(-1)').value,math.complex(0,1),'sqrt(-1)');
					deepCloseEqual(assert, evaluate('sqrt(-49)').value,math.complex(0,7),'sqrt(-49');
					deepCloseEqual(assert, evaluate('sqrt(1+2i)').value,math.complex(1.272019649514068964,0.786151377757423286069),'sqrt(1+2i)');

					closeEqual(assert, evaluate('ln(e)').value,1,'ln(e)');
					closeEqual(assert, evaluate('ln(1)').value,0,'ln(1)');
					deepCloseEqual(assert, evaluate('ln(-2)').value,math.complex(Math.log(2),Math.PI),'ln(-2)');
					deepCloseEqual(assert, evaluate('ln(2+i)').value,math.complex(Math.log(Math.sqrt(5)),Math.atan(0.5)),'ln(2+i)');
					closeEqual(assert, evaluate('log(10)').value,1,'');
					deepCloseEqual(assert, evaluate('log(2+i)').value,math.complex(Math.LOG10E*Math.log(Math.sqrt(5)),Math.LOG10E*Math.atan(0.5)),'log(2+i)');
					closeEqual(assert, evaluate('exp(5)').value,Math.exp(5),'exp(5)');
					closeEqual(assert, evaluate('exp(-2)').value,Math.exp(-2),'exp(-2)');
					deepCloseEqual(assert, evaluate('exp(4-i)').value,math.complex(Math.exp(4)*Math.cos(-1),Math.exp(4)*Math.sin(-1)),'exp(4-i)');

					closeEqual(assert, evaluate('fact(0)').value,1,'fact(0)');
					closeEqual(assert, evaluate('fact(1)').value,1,'fact(1)');
					closeEqual(assert, evaluate('fact(6)').value,720,'fact(6)');
					closeEqual(assert, evaluate('fact(1/2)').value,0.8862269255,'fact(1/2)');
					closeEqual(assert, evaluate('fact(-3/2)').value,-3.5449077018 ,'fact(-3/2)');
					deepCloseEqual(assert, evaluate('fact(i)').value,math.complex(0.4980156681,-0.1549498283),'fact(i)');

					closeEqual(assert, evaluate('root(8,3)').value,2,'root(8,3)');
					deepCloseEqual(assert, evaluate('root(-81,4)').value,math.complex(2.121320343559643,2.121320343559643),'root(-81,4)');
					closeEqual(assert, evaluate('root(4,1.2)').value,3.174802103936399,'root(4,1.2)');
					deepCloseEqual(assert, evaluate('root(i,-2)').value,math.complex(0.7071067811865476,-0.7071067811865476),'root(i,-2)');
				});

				QUnit.test('Trigonometry',function(assert) {
					closeEqual(assert, evaluate('sin(0)').value,0,'sin(0)');
					closeEqual(assert, evaluate('sin(pi/2)').value,1,'sin(pi/2)');
					deepCloseEqual(assert, evaluate('sin(i)').value,math.complex(0,1.175201193643801456882381),'sin(i)');
					closeEqual(assert, evaluate('cos(0)').value,1,'cos(0)');
					closeEqual(assert, evaluate('cos(pi/2)').value,0,'cos(pi/2)');
					deepCloseEqual(assert, evaluate('cos(i)').value,1.5430806348152437784779,'cos(i)');

					closeEqual(assert, evaluate('tan(0)').value,0,'tan(0)');
					closeEqual(assert, evaluate('tan(pi/4)').value,1,'tan(pi/4)');
					deepCloseEqual(assert, evaluate('tan(i)').value,math.complex(0,0.761594155955764888),'tan(i)');

					closeEqual(assert, evaluate('cosec(pi/4)').value,Math.sqrt(2),'cosec(pi/4)');
					deepCloseEqual(assert, evaluate('cosec(i)').value,math.complex(0,-0.850918128239321545133),'cosec(i)');
					closeEqual(assert, evaluate('sec(pi/4)').value,Math.sqrt(2),'sec(pi/4)');
					closeEqual(assert, evaluate('sec(i)').value,1/1.5430806348152437784779,'sec(i)');
					closeEqual(assert, evaluate('cot(1)').value,0.6420926159343307,'cot(1)');
					deepCloseEqual(assert, evaluate('cot(i)').value,math.complex(0,-1.313035285499331303),'cot(i)');

					closeEqual(assert, evaluate('arcsin(0.5)').value,Math.PI/6,'arcsin(0.5)');
					deepCloseEqual(assert, evaluate('arcsin(i*sinh(1))').value,math.complex(0,1),'arcsin(i*sinh(1))');
					deepCloseEqual(assert, evaluate('arcsin(2)').value,math.complex(1.5707963267948966,-1.31695789692481),'arcsin(2)');
					closeEqual(assert, evaluate('arccos(0.5)').value,Math.PI/3,'arccos(0.5)');
					deepCloseEqual(assert, evaluate('arccos(cosh(1))').value,math.complex(0,1),'arccos(cosh(1))');
					closeEqual(assert, evaluate('arctan(1/sqrt(3))').value,Math.PI/6,'arctan(1/sqrt(3))');
					deepCloseEqual(assert, evaluate('arctan(i*tanh(1))').value,math.complex(0,1),'arctan(i*tanh(1))');

					closeEqual(assert, evaluate('sinh(1)').value,Math.E/2-1/(2*Math.E),'sinh(1)');
					closeEqual(assert, evaluate('sinh(ln(2))').value,3/4,'sinh(ln(2))');
					deepCloseEqual(assert, evaluate('sinh(2i)').value,math.complex(0,Math.sin(2)),'sinh(2i)');
					closeEqual(assert, evaluate('cosh(1)').value,Math.E/2+1/(2*Math.E),'cosh(1)');
					closeEqual(assert, evaluate('cosh(ln(3))').value,5/3,'cosh(ln(3))');
					closeEqual(assert, evaluate('cosh(-i)').value,Math.cos(1),'cosh(-i)');
					closeEqual(assert, evaluate('tanh(1)').value,0.7615941559557648,'tanh(1)');
					closeEqual(assert, evaluate('tanh(ln(5))').value,12/13,'tanh(ln(5))');
					deepCloseEqual(assert, evaluate('tanh(1+i)').value,math.complex(1.08392332733869454,0.27175258531951171652),'tanh(1+i)');
					closeEqual(assert, evaluate('cosech(ln(3))').value,3/4,'cosech(ln(3))');
					closeEqual(assert, evaluate('sech(ln(2))').value,4/5,'');
					closeEqual(assert, evaluate('coth(5)').value,1.000090803982019,'coth(5)');
					closeEqual(assert, evaluate('arcsinh(7)').value,2.644120761058629075,'arcsinh(7)');
					closeEqual(assert, evaluate('arccosh(8)').value,2.7686593833135738,'arccosh(8)');
					deepCloseEqual(assert, evaluate('arctanh(1+i)').value,math.complex(0.40235947810852507,1.0172219678978514),'arctanh(1+i)');
				});


				QUnit.test('Vector and Matrix operations',function(assert) {
					closeEqual(assert, evaluate('dot(vector(1,2),vector(2,3))').value,8,'dot(vector(1,2),vector(2,3))');
					closeEqual(assert, evaluate('dot(matrix([1],[2],[3]),vector(6,5,4))').value,28,'dot(matrix([1],[2],[3]),vector(6,5,4))');
					closeEqual(assert, evaluate('dot(vector(6,5,4),matrix([1],[2],[3]))').value,28,'dot(vector(6,5,4),matrix([1],[2],[3]))');
					closeEqual(assert, evaluate('dot(matrix([1],[2],[3]),matrix([1],[2],[3]))').value,14,'dot(matrix([1],[2],[3]),matrix([1],[2],[3]))');
					deepCloseEqual(assert, evaluate('cross(vector(1,2,3),vector(5,6,7))').value,[-4,8,-4],'cross(vector(1,2,3),vector(5,6,7))');
					deepCloseEqual(assert, evaluate('cross(vector(1,2,3),matrix([5,6,7]))').value,[-4,8,-4],'cross(vector(1,2,3),matrix([5,6,7]))');
					deepCloseEqual(assert, evaluate('cross(matrix([1,2,3]),vector(5,6,7))').value,[-4,8,-4],'cross(matrix([1,2,3]),vector(5,6,7))');
					closeEqual(assert, evaluate('det(matrix([2,4],[3,5]))').value,-2,'det(matrix([2,4],[3,5]))');
					raisesNumbasError(assert, function(){ evaluate('det(matrix([2,4,6],[3,5,7]))') },'matrixmath.abs.non-square','error on non-square matrix: det(matrix([2,4,6],[3,5,7]))');
					raisesNumbasError(assert, function(){ evaluate('det(matrix([1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]))') },'matrixmath.abs.too big',"can't work out determinants of big matrices: det(matrix([1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]))");
					deepCloseEqual(assert, evaluate('transpose(vector(1,2,3))').value,[[1,2,3]],'transpose(vector(1,2,3))');
					deepCloseEqual(assert, evaluate('transpose(matrix([1,2,3]))').value,[[1],[2],[3]],'transpose(matrix([1,2,3]))');
					deepCloseEqual(assert, evaluate('transpose(matrix([1],[2],[3]))').value,[[1,2,3]],'transpose(matrix([1],[2],[3]))');
					deepCloseEqual(assert, evaluate('transpose(transpose(matrix([1,2,3])))').value,[[1,2,3]],'transpose(transpose(matrix([1,2,3])))');
					deepCloseEqual(assert, evaluate('id(1)').value,[[1]],'id(1)');
					deepCloseEqual(assert, evaluate('id(2)').value,[[1,0],[0,1]],'id(2)');
					deepCloseEqual(assert, evaluate('id(3)').value,[[1,0,0],[0,1,0],[0,0,1]],'id(3)');
                    deepCloseEqual(assert, evaluate('id(4)').value,[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],'id(4)');
                    deepCloseEqual(assert, evaluate('vector(1,2)*matrix([[1,2],[3,4]])').value,[7,10],'vector*matrix');
				});

				QUnit.test('Range operations',function(assert) {
					deepCloseEqual(assert, evaluate('1..5').value,[1,5,1],'1..5');
					deepCloseEqual(assert, jme.unwrapValue(evaluate('list(1..5)')),[1,2,3,4,5],'list(1..5)');
					deepCloseEqual(assert, evaluate('1..7#2').value,[1,7,2],'1..#7#2');
					deepCloseEqual(assert, jme.unwrapValue(evaluate('list(1..7#2)')),[1,3,5,7],'list(1..#7#2)');
					deepCloseEqual(assert, evaluate('-2..3#2').value,[-2,3,2],'-2..3#2');
					deepCloseEqual(assert, jme.unwrapValue(evaluate('list(-2..3#2)')),[-2,0,2],'list(-2..3#2)');
					deepCloseEqual(assert, jme.unwrapValue(evaluate('list(100..102#1/3)')),[100,100+1/3,100+2/3,101,101+1/3,101+2/3,102],'list(100..102#1/3)');
					deepCloseEqual(assert, jme.unwrapValue(evaluate('list(6..1#-1)')),[6,5,4,3,2,1],'list(6..1#-1)');

					deepCloseEqual(assert, evaluate('1..2#0').value,[1,2,0],'1..2#0');

					deepCloseEqual(assert, evaluate('-3..7 except 0..3').value.map(getValue),[-3,-2,-1,4,5,6,7],'-3..7 except 0..3');
					deepCloseEqual(assert, evaluate('-3..7 except 0.5..3.5').value.map(getValue),[-3,-2,-1,0,1,2,3,4,5,6,7],'-3..7 except 0.5..3.5');
					deepCloseEqual(assert, evaluate('-3..7 except 0.5..3.5#0').value.map(getValue),[-3,-2,-1,0,4,5,6,7],'-3..7 except 0.5..3.5#0');
					raisesNumbasError(assert, function(){ evaluate('0..5#0 except 1..3') },'jme.func.except.continuous range',"can't use except on continuous range: 0..5#0 except 1..3");

					deepCloseEqual(assert, evaluate('-3..7 except 4').value.map(getValue),[-3,-2,-1,0,1,2,3,5,6,7],'-3..7 except 4');
					deepCloseEqual(assert, evaluate('-3..7 except 4.5').value.map(getValue),[-3,-2,-1,0,1,2,3,4,5,6,7],'-3..7 except 4.5');
					raisesNumbasError(assert, function(){ evaluate('0..1#0 except 0.5') },'jme.func.except.continuous range',"can't use except on continuous range: 0..1#0 except 0.5");

					deepCloseEqual(assert, evaluate('-2..11 except [1,2,3,5,8]').value.map(getValue),[-2,-1,0,4,6,7,9,10,11],'-2..11 except [1,2,3,5,8]');
					deepCloseEqual(assert, evaluate('-2..11 except []').value.map(getValue),[-2,-1,0,1,2,3,4,5,6,7,8,9,10,11],'-2..11 except []');
					deepCloseEqual(assert, evaluate('-2..2 except [1,"a",0]').value.map(getValue),[-2,-1,2],'-2..2 except [1,"a",0]');
					raisesNumbasError(assert, function(){ evaluate('0..5#0 except 1..3') },'jme.func.except.continuous range',"can't use except on continuous range: 0..5#0 except 1..3");

					deepCloseEqual(assert, evaluate('-11 in -9..9').value,false,'-11 not in -9..9');
					deepCloseEqual(assert, evaluate('3 in -9..9#0').value,true,'3 in -9..9#0');
				});


				QUnit.test('List operations',function(assert) {
					deepCloseEqual(assert, evaluate('["a","b","c"] except "a"').value.map(getValue),['b','c'],'["a","b","c"] except "a"');
					deepCloseEqual(assert, evaluate('["a","b","c"] except ["a","c","f"]').value.map(getValue),['b'],'["a","b","c"] except ["a","c","f"]');
                    deepCloseEqual(assert, evaluate('["a","b","c","d","e"][0..2]').value.map(getValue),['a','b'],'["a","b","c","d","e"][0..2]');

                    assert.equal(evaluate("all([])").value,true,"all([])");
                    assert.equal(evaluate("all([true])").value,true,"all([true])");
                    assert.equal(evaluate("all([false])").value,false,"all([false])");
                    assert.equal(evaluate("all([1])").value,false,"all([1])");
                    assert.equal(evaluate("all([true,false])").value,false,"all([true,false])");
                    assert.equal(evaluate("all([false,true])").value,false,"all([false,true])");
                    assert.equal(evaluate("all([true,true])").value,true,"all([true,true])");

                    assert.equal(evaluate("some([])").value,false,"some([])");
                    assert.equal(evaluate("some([true])").value,true,"some([true])");
                    assert.equal(evaluate("some([false])").value,false,"some([false])");
                    assert.equal(evaluate("some([1])").value,false,"some([1])");
                    assert.equal(evaluate("some([true,false])").value,true,"some([true,false])");
                    assert.equal(evaluate("some([false,true])").value,true,"some([false,true])");
                    assert.equal(evaluate("some([true,true])").value,true,"some([true,true])");
                    assert.equal(evaluate("some([false,false])").value,false,"some([false,false])");
                });

                QUnit.test('Dictionaries',function(assert) {
                    assert.ok(compile('["a": -1]','prefix operation as value of dictionary item'));
                    deepCloseEqual(assert, evaluate('["a": 1]["a"]').value,1,'["a": 1]["a"] = 1');
                    raisesNumbasError(assert, function() { evaluate('["a": 1]["b"]') }, 'jme.func.listval.key not in dict', '["a": 1]["b"]');
                    deepCloseEqual(assert, evaluate('keys( ["a": 1, "b": 2] )').value.map(getValue), ['a','b'],'keys( ["a":1,"b": 2] )');
                    deepCloseEqual(assert, evaluate('values( ["a": 1, "b": 2] )').value.map(getValue), [1,2],'values( ["a":1,"b": 2] )');
                    deepCloseEqual(assert, jme.unwrapValue(evaluate('items( ["a": 1, "b": 2] )')), [['a',1],['b',2]],'items( ["a":1,"b": 2] )');
                    assert.equal(evaluate('"a" in ["a": 1]').value,true,'"a" in ["a": 1]');
                    assert.equal(evaluate('"b" in ["a": 1]').value,false,'"b" in ["a": 1]');
                    assert.equal(evaluate('"__proto__" in dict()').value,false,'"__proto__" in dict()');
                    deepCloseEqual(assert, jme.unwrapValue(evaluate('["a":1,"b":2]+["a":4,"c":3]')),{a:4,b:2,c:3},'["a":1,"b":2]+["a":4,"c":3]');
                    deepCloseEqual(assert, jme.unwrapValue(evaluate('map(let(bits,x,["a":bits]),x,[1,2,3])')),[{a:1},{a:2},{a:3}],'map(let(bits,x,["a":bits]),x,[1,2,3])');
                    deepCloseEqual(assert, jme.unwrapValue(evaluate('dict([["a",1],["b",2]])')),{a:1,b:2},'dict([["a",1],["b",2]])');
                });

				QUnit.test('Branching',function(assert) {
					closeEqual(assert, evaluate('if(true,1,0)').value,1,'if(true,1,0)');
					closeEqual(assert, evaluate('if(false,1,0)').value,0,'if(false,1,0,)');
					closeEqual(assert, evaluate('if(true,1,1<i)').value,1,'lazy evaluation: if(true,1,1<i)');
					closeEqual(assert, evaluate('if(false,1<i,1)').value,1,'lazy evaluation: if(false,1<i,1)');

					closeEqual(assert, evaluate('switch(true,1,0)').value,1,'switch(true,1,0)');
					closeEqual(assert, evaluate('switch(false,1,true,2,3)').value,2,'switch(false,1,true,2,3)');
					closeEqual(assert, evaluate('switch(false,1,false,2,3)').value,3,'switch(false,1,false,1,3)');
					closeEqual(assert, evaluate('switch(false,1,true,0)').value,0,'switch(false,1,true,0)');
					raisesNumbasError(assert, function(){ evaluate('switch(false,1,false,0)') },'jme.func.switch.no default case','no default case: switch(false,1,false,0)');
				});

				QUnit.test('Repetition',function(assert) {
					deepCloseEqual(assert, evaluate('map(x+1,x,[1,2,3])').value.map(getValue),[2,3,4],'map(x+1,x,[1,2,3])');
					deepCloseEqual(assert, evaluate('map(x+1,x,1..3)').value.map(getValue),[2,3,4],'map(x+1,x,1..3)');
					raisesNumbasError(assert, function(){evaluate('map(x+1,x,2)')},'jme.typecheck.map not on enumerable',"Can\'t map over things that aren\'t lists or ranges");
					deepCloseEqual(assert, evaluate('repeat(1,5)').value.map(getValue),[1,1,1,1,1],'repeat(1,5)');
					closeEqual(assert, evaluate('repeat(random(3..6),5)').value.length,5,'repeat(random(3..6),5) produces 5 values');
					var n = evaluate('repeat(random(3..6),5)[4]').value;
					closeEqual(assert, n>=3 && n<=6,true,'last item in repeat(random(3..6),5) is in the correct range');
				});

				QUnit.test('wrapValue',function(assert) {
					var m = [[0]];
					m.rows = 1;
					m.columns = 1;
					assert.equal(jme.wrapValue(m).type,'list','wrapValue on list without type hint gives list');
                    assert.equal(jme.wrapValue(m,'matrix').type,'matrix','wrapValue on list with matrix type hint');
                    assert.equal(jme.wrapValue(null).type,'string','wrapValue on null gives empty string');
                    assert.equal(jme.wrapValue({a:1}).type,'dict','wrapValue on object gives dict');
                    assert.equal(jme.wrapValue(new Numbas.jme.types.TList(1)).type,'list','wrapValue on a token returns it unchanged');
				});

                QUnit.test('isRandom',function(assert) {
                    function check(expr,expected) {
                        assert.equal(jme.isRandom(jme.compile(expr),Numbas.jme.builtinScope),expected,expr);
                    }

                    check('1',false);
                    check('random(1,2)',true);
                    check('1+random(3,4)',true);
                    check('[1]',false);
                    check('[random(1,2)]',true);
                    check('["A":1]',false);
                    check('["A":random("b","c")]',true);
                    check('f(random(1,2))',true);
                });

				
				QUnit.module('Scopes');

				QUnit.test('Variables',function(assert) {
                    deepCloseEqual(assert, jme.builtinScope.variables,{"nothing": new Numbas.jme.types.TNothing},'builtin scope has only a "nothing" variable');
					deepCloseEqual(assert, new jme.Scope().variables,{},'scope from constructor has no variables');
					var scope = new jme.Scope({
						variables: {
							x: new types.TNum(1),
							y: new types.TString('hi')
						}
					});
					assert.ok(scope.getVariable('x'),'add variables in scope constructor')
					var scope2 = new jme.Scope([scope,{variables: {x: new types.TNum(2)}}]);
					closeEqual(assert, scope2.getVariable('x').value,2,'override variable in old scope with new value');
					closeEqual(assert, scope2.getVariable('y').value,'hi','but other variables retained if not defined in later scope');
				});

				QUnit.test('Functions',function(assert) {
					assert.ok(jme.builtinScope.getFunction('+'),'builtin scope has functions in it.');
					deepCloseEqual(assert, new jme.Scope().functions,{},'scope from constructor has no functions');
					var scope = new jme.Scope([jme.builtinScope,{
						functions: {
							'+':[(new jme.funcObj('+',[types.TBool,types.TBool],types.TBool,null,{nobuiltin:true}))]
						}
					}]);
					closeEqual(assert, scope.getFunction('+').length,jme.builtinScope.getFunction('+').length+1,'add overloaded function to old scope');
					closeEqual(assert, new Numbas.jme.Scope([scope,jme.builtinScope]).getFunction('+').length,scope.getFunction('+').length,"don't duplicate functions when extending scope");
				});

				QUnit.test('Rulesets',function(assert) {
					deepCloseEqual(assert, new jme.Scope().rulesets,{},'scope from constructor has no rulesets');
					var scope = new jme.Scope({rulesets: jme.display.simplificationRules});
					assert.ok(scope.getRuleset('basic'),'extend scope with some rulesets');
				});


				QUnit.module('Display');

				QUnit.test('niceNumber',function(assert) {
					assert.equal(Numbas.math.niceNumber(1000,{precisionType:'sigfig',precision:2}),'1000','niceNumber with sigfig precision calculates number of zeroes to add correctly');
					assert.equal(Numbas.math.niceNumber(1010,{precisionType:'sigfig',precision:6}),'1010.00','niceNumber with sigfig precision calculates number of zeroes to add correctly');
					assert.equal(Numbas.math.niceNumber(Infinity),'infinity','niceNumber recognises infinity');
					assert.equal(Numbas.math.niceNumber(-Infinity),'-infinity','niceNumber recognises -infinity');
					assert.equal(Numbas.math.niceNumber(-Math.PI),'-pi','niceNumber on -pi doesn\'t say -1pi');
                    assert.equal(Numbas.math.niceNumber(Math.PI,{precisionType: 'dp', precision:2}),'3.14','niceNumber doesn\'t show pi when given a precisionType');
                    assert.equal(Numbas.math.niceNumber(6e-10,{precisionType:'sigfig',precision:3}),'0.000000000600','niceNumber adds digits to exponential-form numbers correctly');
                    assert.equal(Numbas.math.niceNumber(2.2e-10,{precisionType:'sigfig',precision:3}),'0.000000000220','niceNumber adds digits to exponential-form numbers correctly');
                    assert.equal(Numbas.math.niceNumber(2e-10,{precisionType:'dp',precision:12}),'0.000000000200','niceNumber adds digits to exponential-form numbers correctly');
                    assert.equal(Numbas.math.niceNumber(2.2e-10,{precisionType:'dp',precision:12}),'0.000000000220','niceNumber adds digits to exponential-form numbers correctly');
				});

                QUnit.test('Number notation styles',function(assert) {
                    var tests = {
                        en: [
                            ['0','0',0],
                            ['-0','-0',0,'0'],
                            ['1','1',1],
                            ['0.1','0.1',0.1],
                            ['123','123',123],
                            ['1,234','1234',1234],
                            ['1,234,567.89','1234567.89',1234567.89],
                            ['-1,234.0','-1234.0',-1234,'-1,234'],
                            ['1,2,3','1,2,3',NaN]
                        ],
                        'si-en': [
                            ['0','0',0],
                            ['-0','-0',0,'0'],
                            ['1','1',1],
                            ['0.1','0.1',0.1],
                            ['123','123',123],
                            ['1 234','1234',1234],
                            ['1 234 567.89','1234567.89',1234567.89],
                            ['-1 234.0','-1234.0',-1234,'-1 234'],
                            ['1 2 3','1 2 3',NaN]
                        ],
                        eu: [
                            ['0','0',0],
                            ['-0','-0',0,'0'],
                            ['1','1',1],
                            ['0,1','0.1',0.1],
                            ['123','123',123],
                            ['1.234','1234',1234],
                            ['1.234.567,89','1234567.89',1234567.89],
                            ['-1.234,0','-1234.0',-1234,'-1.234'],
                            ['1.2.3','1.2.3',NaN]
                        ],
                        'si-fr': [
                            ['0','0',0],
                            ['-0','-0',0,'0'],
                            ['1','1',1],
                            ['0,1','0.1',0.1],
                            ['123','123',123],
                            ['1 234','1234',1234],
                            ['1 234 567,89','1234567.89',1234567.89],
                            ['-1 234,0','-1234.0',-1234,'-1 234'],
                            ['1 2 3','1 2 3',NaN]
                        ],
                        ch: [
                            ["0","0",0],
                            ["-0","-0",0,"0"],
                            ["1","1",1],
                            ["0.1","0.1",0.1],
                            ["123","123",123],
                            ["1'234","1234",1234],
                            ["1'234'567.89","1234567.89",1234567.89],
                            ["-1'234.0","-1234.0",-1234,"-1'234"],
                            ["1'2'3","1'2'3",NaN]
                        ],
                        in: [
                            ['0','0',0],
                            ['-0','-0',0,'0'],
                            ['1','1',1],
                            ['0.1','0.1',0.1],
                            ['123','123',123],
                            ['1,234','1234',1234],
                            ['12,34,567.89','1234567.89',1234567.89],
                            ['1,23,456.78','123456.78',123456.78],
                            ['-1,234.0','-1234.0',-1234,'-1,234'],
                            ['1,2,3','1,2,3',NaN]
                        ],
                    }
                    for(var style in tests) {
                        tests[style].forEach(function(t) {
                            var input = t[0];
                            var cleaned = t[1];
                            var value = t[2];
                            assert.equal(Numbas.util.cleanNumber(input,style),cleaned,'clean '+style+' '+input);
                            var v = Numbas.util.parseNumber(input,false,style);
                            if(isNaN(value)) {
                                assert.equal(isNaN(v),true,'parse '+style+' '+input);
                            } else {
                                assert.equal(v,value,'parse '+style+' '+input);
                                var formatted = t[3]===undefined ? input : t[3];
                                assert.equal(Numbas.math.niceNumber(value,{style:style}),formatted,'format '+style+' '+value);
                            }
                        });
                    }
                });

				QUnit.test('subvars',function(assert) {
					assert.ok(Numbas.jme.texsplit('boo\r\\simplify{}'),'texsplit copes with \\r characters OK.');
				});

				QUnit.test('tree to JME', function(assert) {
					function simplifyExpression(expr,rules) {
						return Numbas.jme.display.simplifyExpression(expr,rules || '',Numbas.jme.builtinScope);
					}
					assert.equal(simplifyExpression('(a/b)*(c/d)'),'(a/b)(c/d)','(a/b)*(c/d) - fractions remain separate');
					assert.equal(simplifyExpression('(-7)/(-4+5i)','all'),'7/(4 - 5i)','(-7)/(-4+5i) - unary minus brought out of complex number properly');
					assert.equal(simplifyExpression('-4+5i','all'),'-4 + 5i','-4+5i - unary minus brought out of complex number properly');
					assert.equal(simplifyExpression('(1-i)+(-2+2i)',''),'1 - i - 2 + 2i','(1-i)+(-2+2i) - addition of complex numbers with negative imaginary parts');
					assert.equal(simplifyExpression('(1-i)-(-2+2i)',''),'1 - i + 2 - 2i','(1-i)-(-2+2i) - addition of complex numbers with negative imaginary parts');
					assert.equal(simplifyExpression('10000000000000000000000000'),'1*10^(25)','scientific notation - 1*e^25');
					assert.equal(simplifyExpression('47652000000000000000000000'),'4.7652*10^(25)','scientific notation - 4.7652*e^25');
					assert.equal(simplifyExpression('x+(-10+2)','basic,collectNumbers'),'x - 8','x+(-10+2) - negative number in the middle of an addition gets cancelled through properly');
					assert.equal(simplifyExpression('4-(x^2+x+1)',[]),'4 - (x^2 + x + 1)','4-(x^2+x+1) - brackets round right-hand operand in subtraction kept when they\'re wrapping an addition.');
					assert.equal(simplifyExpression('(x^2+x)-4',[]),'x^2 + x - 4','(x^2+x)-4 - brackets round left-hand operand in subtraction can be dropped.');
					assert.equal(simplifyExpression('pi*i',['all']),'pi*i','pi*i - don\'t lose multiplication symbol.');
					assert.equal(Numbas.jme.compile(Numbas.jme.display.treeToJME(Numbas.jme.compile('"\\\\textrm{hi}\\nso"'))).tok.value,"\\textrm{hi}\nso",'treeToJME escapes backslashes');
					assert.equal(simplifyExpression('-3x-4',['all']),'-3x - 4','-3x-4 doesn\'t get rearranged to -(3x+4) by collectNumbers');
					assert.equal(simplifyExpression('x-(5-p)',[]),'x - (5 - p)','x-(5-p) keeps the right-hand brackets');

					assert.equal(simplifyExpression('3!',[]),'3!','3!');
					assert.equal(simplifyExpression('(3+1)!',[]),'(3 + 1)!','(3+1)!');

					assert.equal(simplifyExpression('pi*x',['all']),'pi*x','pi*x doesn\t omit the *');
					assert.equal(simplifyExpression('e*x',['all']),'e*x','e*x doesn\t omit the *');
					assert.equal(simplifyExpression('1*pi/4',['all']),'pi/4','1*pi/4 cancels the 1');
					assert.equal(simplifyExpression('2*pi/4',['all']),'pi/2','2*pi/4 cancels the integer factor');
					assert.equal(simplifyExpression('15*pi/12',['all']),'(5 pi)/4','15*pi/12 cancels the integer factor');
					assert.equal(simplifyExpression('21*pi/12',['all']),'(7 pi)/4','21*pi/12 cancels the integer factor');
					assert.equal(simplifyExpression('2*pi*x/4',['all']),'(pi*x)/2','2*pi*x/4 cancels the integer factor');
					assert.equal(simplifyExpression('x/(2 pi^2)',['all']),'x/(2 pi^2)','x/(2 pi^2) brackets the multiple of pi');
					assert.equal(simplifyExpression('2*x/(4*pi^2)',['all']),'x/(2 pi^2)','2*x/(4*pi^2) cancels the integer factor');
					assert.equal(simplifyExpression('2i/4',['all']),'i/2','2*i/4 cancels the integer factor');
					assert.equal(simplifyExpression('2/(4i)',['all']),'1/(2i)','2/(4i) cancels the integer factor');
					assert.equal(simplifyExpression('2i/(4i)',['all']),'1/2','2i/(4i) cancels the i');
					assert.equal(simplifyExpression('(2+i)/3',['all']),'(2 + i)/3','(2+i)/3 puts brackets around the complex numerator');
					assert.equal(simplifyExpression('-0',['noleadingminus']),'0','-0 rewritten to 0 with noleadingminus');
                    assert.equal(simplifyExpression('-0',['all','!noleadingminus']),'-0','-0 not rewritten to 0 without noleadingminus');
					
					assert.equal(simplifyExpression('5^0',['zeroPower']),'1','5^0 simplified by zeroPower');
					assert.equal(simplifyExpression('x^0',['zeroPower']),'1','x^0 simplified');
					assert.equal(simplifyExpression('0^5',['zeroBase']),'0','0^5 simplified by zeroBase');
					assert.equal(simplifyExpression('0^x',['zeroBase']),'0','0^x simplified');
					assert.equal(simplifyExpression('5^0',['otherNumbers']),'1','5^0 simplified by otherNumbers');
					assert.equal(simplifyExpression('0^5',['otherNumbers']),'0','0^5 simplified by otherNumbers');
					assert.equal(simplifyExpression('0^0',['all']),'0^0','0^0 not simplified');
					
					assert.equal(simplifyExpression('cos(0.5pi)',['all']),'0','cos(0.5pi) evaluated');
					assert.equal(simplifyExpression('cos(pi/2)',['all']),'0','cos(pi/2) evaluated');
					assert.equal(simplifyExpression('cos(1.5pi)',['all']),'0','cos(1.5pi) evaluated');
					assert.equal(simplifyExpression('cos(1.5pi)',['all','calcError']),'0','cos(1.5pi) evaluated with calcError');
					assert.equal(simplifyExpression('cos(3pi/2)',['all']),'0','cos(3pi/2) evaluated');
					assert.equal(simplifyExpression('cos(3pi/2)',['all','calcError']),'0','cos(3pi/2) evaluated with calcError');
					assert.equal(simplifyExpression('sin(0.5pi)',['all']),'1','sin(0.5pi) evaluated');
					assert.equal(simplifyExpression('sin(pi/2)',['all']),'1','sin(pi/2) evaluated');
					assert.equal(simplifyExpression('sin(1.5pi)',['all']),'-1','sin(1.5pi) evaluated');
					assert.equal(simplifyExpression('sin(3pi/2)',['all']),'-1','sin(3pi/2) evaluated');
					
					assert.equal(simplifyExpression('cos(0.25pi)',['all','trigSurds']),'1/sqrt(2)','cos(0.25pi) evaluated');
					assert.equal(simplifyExpression('sin(5pi/6)',['all','trigSurds']),'1/2','sin(5pi/6) evaluated');
					assert.equal(simplifyExpression('i^2*tan(5pi/3)',['all','trigSurds']),'sqrt(3)','i^2*tan(5pi/3) evaluated');
					assert.equal(simplifyExpression('i^2*tan(5pi/3)',['all','trigSurds','calcError']),'sqrt(3)','i^2*tan(5pi/3) evaluated with calcError');

                    assert.equal(simplifyExpression('y+(1-2)x',['all']),'y - x','Collect numbers resulting in a negative');
                    assert.equal(simplifyExpression('x+(1-2)/x',['all']),'x - 1/x','Collect numbers resulting in a negative');

                    assert.equal(simplifyExpression('x^0.5',{flags:{fractionnumbers:true}}),'x^(1/2)','x^0.5 with fractionNumbers puts brackets around the fraction');

                    assert.equal(simplifyExpression('(x+1)(x+2)(x+3)(x+4)','all,canonicalOrder,expandBrackets,!noleadingminus'),'x^4 + 10*x^3 + 35*x^2 + 50x + 24','Large product expanded and collected');
                    assert.equal(simplifyExpression('(x+1)(x-2)(x+3)(x+4)','all,canonicalOrder,expandBrackets,!noleadingminus'),'x^4 + 2*x^3 - 13*x^2 - 26x - 24','Large product with a negative term expanded and collected');
                    assert.equal(simplifyExpression('(x^2+4x+1)(x^2+2x+1)','all'),'(x^2 + 4x + 1)(x^2 + 2x + 1)','cancelFactors on polynomials differing only by coefficients');
                    assert.equal(simplifyExpression('(x^2+4x+1)(x^2+4x+1)','all'),'(x^2 + 4x + 1)^2','cancelFactors on equal polynomials');
					
					assert.equal(simplifyExpression('tanh(-x)',['oddEven']),'-tanh(x)','minus sign pulled out from tanh');
					assert.equal(simplifyExpression('(-x)^4',['oddEven']),'x^4','minus sign pulled out from (-x)^4');
					
					assert.equal(simplifyExpression('2x+2y',['all','commonFactors']),'2(x + y)','pull out common integer factor');
					assert.equal(simplifyExpression('2.5x+2.5y',['all','commonFactors']),'2.5(x + y)','pull out common decimal factor');
					assert.equal(simplifyExpression('(2-3i)x+(2-3i)y',['all','commonFactors']),'(2 - 3i)(x + y)','pull out common complex factor');
					assert.equal(simplifyExpression('2x+2y+2z',['all','commonFactors']),'2(x + y + z)','pull out common integer factor, three terms');

					var html = Numbas.jme.evaluate('html("<div class=\\"thing\\">this</div>")',Numbas.jme.builtinScope);
					assert.equal(Numbas.jme.display.treeToJME({tok:html}),'html("<div class=\\"thing\\">this</div>")','treeToJME serialises HTML');

                    var r = new Numbas.jme.rules.Rule('?;m*?;n',['m isa "number"'],'eval(m*n)');
                    var s = new Numbas.jme.Scope([Numbas.jme.builtinScope,{variables: {x: new Numbas.jme.types.TNum(2)}}]);
                    var m = r.match(Numbas.jme.compile('x*2'),s);
                    assert.equal(m,false,"don't sub variables from the scope when checking simplification rule conditions");

                    assert.equal(Numbas.jme.display.simplifyExpression('4x+2','all',s),'4x + 2','x is defined in the scope as a number');
				});

				QUnit.test('texName', function(assert) {
					var names = [
						{name: 'x', tex: 'x'},
						{name: 'xy', tex: '\\texttt{xy}'},
						{name: 'xyz', tex: '\\texttt{xyz}'},
						{name: 'x1', tex: 'x_{1}'},
						{name: 'x1234', tex: 'x_{1234}'},
						{name: 'x1\'', tex: 'x_{1}\''},
						{name: 'x_1', tex: 'x_{1}'},
						{name: 'x_12345', tex: 'x_{12345}'},
						{name: 'x_123\'\'', tex: 'x_{123}\'\''},
						{name: 'longname', tex: '\\texttt{longname}'},
						{name: 'ab_cd_ef', tex: '\\texttt{ab_cd_ef}'},
						{name: 'x_abc', tex: '\\texttt{x_abc}'},
						{name: 'x_abc\'', tex: '\\texttt{x_abc\'}'},
						{name: '\\operatorname{x}', tex: '\\operatorname{x}'},
						{name: 'lambda', tex: '\\lambda'},
						{name: 'lambda1', tex: '\\lambda_{1}'},
						{name: 'lambda\'', tex: '\\lambda\''},
						{name: 'x_y\'', tex: 'x_{y}\''},
						{name: 'x_1', tex: '\\dot{x}_{1}', annotations: ['dot'], description: 'annotations only apply to the root, not subscripts'}
					]

					names.forEach(function(n) {
						assert.equal(Numbas.jme.display.texName(n.name,n.annotations),n.tex, n.description || ('texName '+n[0]));
					});
				});

				QUnit.test('expression to LaTeX', function(assert) {
					function exprToLaTeX(expr,rules) {
						return Numbas.jme.display.exprToLaTeX(expr,rules || '',Numbas.jme.builtinScope);
					}
					assert.equal(exprToLaTeX('-2+i'),'-2 + i','-2+i -- interaction of unary minus with complex number');	
					assert.equal(exprToLaTeX('1+i +(-2+2i)'),'1 + i - 2 + 2 i','1+i +(-2+2i) -- interaction of minus with complex number');	
					assert.equal(exprToLaTeX('1-i +(-2+2i)'),'1 - i - 2 + 2 i','1+i +(-2+2i) -- interaction of minus with complex number');	
					assert.equal(exprToLaTeX('10000000000000000000000000'),'1 \\times 10^{25}','scientific notation - 1*e^25');
					assert.equal(exprToLaTeX('47652000000000000000000000'),'4.7652 \\times 10^{25}','scientific notation - 4.7652*e^25');
					assert.equal(exprToLaTeX('ln(abs(x))'),'\\ln \\left | x \\right |','ln(abs(x)) - ln of absolute value has no parentheses');
					assert.equal(exprToLaTeX('ln(x)'),'\\ln \\left ( x \\right )','ln(x) - ln of anything else has parentheses');
					assert.equal(exprToLaTeX('4-(x^2+x+1)',[]),'4 - \\left ( x^{ 2 } + x + 1 \\right )','4-(x^2+x+1) - brackets round right-hand operand in subtraction kept when they\'re wrapping an addition.');
					assert.equal(exprToLaTeX('(x^2+x+1)-4',[]),'x^{ 2 } + x + 1 - 4','(x^2+x+1)-4 - brackets round left-hand operand in subtraction can be dropped.');
					assert.equal(exprToLaTeX('x-(-1.5)','fractionnumbers,all'),'x + \\frac{3}{2}','x-(-1.5) with args [fractionNumbers,all] - display flags get carried through properly');
					assert.equal(exprToLaTeX('x-(5-p)',[]),'x - \\left ( 5 - p \\right )','x-(5-p) - keep the brackets on the right');
					assert.equal(exprToLaTeX('3*5^2*19',['basic']),'3 \\times 5^{ 2 } \\times 19','3*5^2*19 with basic - always put a \\times between two digits')
					assert.equal(exprToLaTeX('exp(x)^2'),'\\left ( e^{ x } \\right )^{ 2 }','exp(x)^2 - put brackets round e^x')
					assert.equal(exprToLaTeX('-(-x)',[]),'-\\left ( -x \\right )','-(-x) - brackets around repeated minus')
					assert.equal(exprToLaTeX('+(-x)',[]),'+\\left ( -x \\right )','+(-x) - brackets around minus straight after addition')
					assert.equal(exprToLaTeX('3+(-2)',[]),'3 + \\left ( -2 \\right )','3+(-2) - brackets around minus on right side of addition')
					assert.equal(exprToLaTeX('3-(-2)',[]),'3 - \\left ( -2 \\right )','3-(-2) - brackets around minus on right side of subtraction')
					assert.equal(exprToLaTeX('2+(3+2)+(4-5)',[]),'2 + 3 + 2 + 4 - 5','don\'t put brackets round nested addition and subtraction')
					assert.equal(exprToLaTeX('lambda1\'(x)'),'\\lambda_{1}\' \\left ( x \\right )','texName works on function names');
					assert.equal(exprToLaTeX('long_function_name(x)'),'\\operatorname{long\\_function\\_name} \\left ( x \\right )','long function names are wrapped in \\operatorname');
					assert.equal(exprToLaTeX('fact(3)*fact(2)'),'3! \\times 2!','times sign between factorials');
					assert.equal(exprToLaTeX('not a'),'\\neg a','logical NOT');
                    assert.equal(exprToLaTeX('7*(5x+y)'),'7 \\left ( 5 x + y \\right )','don\'t insert times symbol when there\'s a bracket');
                    assert.equal(exprToLaTeX('(5 + 9i)*(2 + 7)'),'\\left ( 5 + 9 i \\right ) \\left ( 2 + 7 \\right )','put brackets around complex numbers when multiplying and neither Re nor Im are zero');
                    assert.equal(exprToLaTeX('(-7+9i)*(x+1)'), '\\left ( -7 + 9 i \\right ) \\left ( x + 1 \\right )','don\'t unnecessarily take unary minus out when it\'s on a complex number');
                    assert.equal(exprToLaTeX('(0.5)^3','fractionnumbers'), '\\left ( \\frac{1}{2} \\right )^{ 3 }', 'bracket fractions taken to a power');
                    assert.equal(exprToLaTeX('(5)^3','fractionnumbers'), '5^{ 3 }', 'don\'t bracket whole numbers taken to a power');
                    assert.equal(exprToLaTeX('(1+i)^3','fractionnumbers'), '\\left ( 1 + i \\right )^{ 3 }', 'bracket complex numbers taken to a power');
                    assert.equal(exprToLaTeX('2*e^2'),'2 e^{ 2 }','');
                    assert.equal(exprToLaTeX('2 * pi'), '2 \\pi','');
                    assert.equal(exprToLaTeX('2 * e'), '2 e','');
                    assert.equal(exprToLaTeX('2*(i^3)'), '2 i^{ 3 }','');
                    assert.equal(exprToLaTeX('x*i'), 'x i','');
                    assert.equal(exprToLaTeX('x*i','alwaystimes'), 'x \\times i','');
                    assert.equal(exprToLaTeX('2^3 * 2^3 * 2^3','basic'),'2^{ 3 } \\times 2^{ 3 } \\times 2^{ 3 }','several consecutive multiplications');
                    assert.equal(exprToLaTeX('sin(x)^5'),'\\sin^{5}\\left( x \\right)','trig function to a positive integer power');
                    assert.equal(exprToLaTeX('sin(x)^(-1)'),'\\sin \\left ( x \\right )^{ -1 }','trig function to a positive integer power');
                    assert.equal(exprToLaTeX('infinity',''),'\\infty','infinity');
                    assert.equal(exprToLaTeX('infinity','fractionNumbers'),'\\infty','infinity with fractionNumbers');
                    assert.equal(exprToLaTeX('e','fractionNumbers'),'e','e with fractionNumbers');
                    assert.equal(exprToLaTeX('pi','fractionNumbers'),'\\pi','pi with fractionNumbers');
                    assert.equal(exprToLaTeX('e^(3x)','fractionNumbers'),'e^{ 3 x }','e^(3x) with fractionNumbers');
                    assert.equal(exprToLaTeX('e*i',''),'e i','e*i');
				});
			});
		</script>
	</body>
</html>
